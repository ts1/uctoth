#!/usr/bin/env coffee
fs = require 'fs'
require './rejection_handler'
{ Board, BLACK, WHITE, EMPTY, pos_from_str, square_to_char, pos_to_str } = require './board'
{ PatternBoard } = require './pattern'
Player = require './player'
pattern_eval = require './pattern_eval'
{ decode } = require './encode'

argv = require 'yargs'
  .options
    v:
      desc: 'Verbose mode'
      alias: 'verbose'
      type: 'boolean'
      default: false
    w:
      alias: 'wld'
      desc: 'Depth of win-loss-draw endgame search'
      type: 'number'
      default: 18
      requiresArg: true
    f:
      alias: 'full'
      desc: 'Depth of full endgame search'
      type: 'number'
      default: 16
      requiresArg: true
    s:
      alias: 'search'
      desc: 'Number of UCT searches'
      type: 'number'
      default: 40000
      requiresArg: true
    r:
      alias: 'ref'
      desc: 'Reference scores.json'
      type: 'string'
      default: 'ref/scores.json'
      requiresArg: true
    S:
      alias: 'scores'
      desc: 'scores.json file'
      type: 'string'
      default: 'scores.json'
      requiresArg: true
    o:
      alias: 'openings'
      desc: 'Openings file'
      type: 'string'
      default: 'match.openings'
      requiresArg: true
    minimax:
      desc: 'Match versus minimax'
      type: 'boolean'
      default: false
    depth:
      desc: 'Depth of minimax search'
      type: 'number'
      default: 9
      requiresArg: true
    simple:
      desc: 'Match versus simple_eval'
      type: 'boolean'
      default: false
    h:
      alias: 'help'
  .strict()
  .version false
  .argv

simple = Player
  book: null
  strategy: require('./uct')
    evaluate: require('./simple_eval')
    verbose: argv.verbose
    board_class: Board
    max_search: argv.search
  solve_wld: argv.wld
  solve_full: argv.full
  verbose: argv.verbose

minmax = Player
  book: null
  strategy: require('./minmax')
    evaluate: pattern_eval(argv.scores)
    max_depth: argv.depth
    shuffle: false
    verbose: argv.verbose
  solve_wld: argv.wld
  solve_full: argv.full
  verbose: argv.verbose

uct = Player
  book: null
  strategy: require('./uct')
    evaluate: pattern_eval(argv.scores)
    verbose: argv.verbose
    max_search: argv.search
  solve_wld: argv.wld
  solve_full: argv.full
  verbose: argv.verbose

uct_ref = Player
  book: null
  strategy: require('./uct')
    evaluate: pattern_eval(argv.ref)
    verbose: argv.verbose
    max_search: argv.search
  solve_wld: argv.wld
  solve_full: argv.full
  verbose: argv.verbose

players = [uct]
players.push if argv.minimax
               minmax
             else if argv.simple
               simple
             else
               uct_ref

play = (board, black, white) ->
  turn = if board.count(EMPTY) & 1 then WHITE else BLACK
  while true
    if argv.v
      console.log board.dump true
      console.log square_to_char(turn), 'to move'
      console.log square_to_char(BLACK), board.count(BLACK), 'discs', board.list_moves(BLACK).length, 'moves'
      console.log square_to_char(WHITE), board.count(WHITE), 'discs', board.list_moves(WHITE).length, 'moves'
      console.log square_to_char(EMPTY), board.count(EMPTY), 'squares'
    if board.any_moves(turn)
      switch turn
        when BLACK then player = black
        when WHITE then player = white
      {move, value} = player(board, turn)
      process.stdout.write pos_to_str(move, turn) unless argv.v
      flips = board.move turn, move
      console.assert flips.length
      console.log 'Estimated value', value if argv.v and value?
    else
      if board.any_moves(-turn)
        console.log 'PASS' if argv.v
      else
        process.stdout.write " #{ board.outcome()}\n" unless argv.v
        return board.outcome()
    turn = -turn

wins = [0, 0]
score = 0
draws = 0

do ->
  n_matches = 0
  sum_square_offset = 0
  for code in fs.readFileSync(argv.openings, 'utf8').trim().split('\n')
    b = decode code
    board = new PatternBoard b
    console.log board.dump true
    outcome = play board, players[0], players[1]
    score += outcome
    offset = outcome
    if outcome > 0
      wins[0]++
    else if outcome < 0
      wins[1]++
    else
      draws++
    n_matches++

    board = new PatternBoard b
    outcome = play board, players[1], players[0]
    score -= outcome
    offset += outcome
    if outcome > 0
      wins[1]++
    else if outcome < 0
      wins[0]++
    else
      draws++
    n_matches++

    offset /= 2
    sum_square_offset += offset * offset

    console.log 'player[0]', wins[0], 'wins'
    console.log 'player[1]', wins[1], 'wins'
    console.log 'draws', draws
    winrate = (wins[0] + draws/2) / n_matches
    console.log 'win rate for player[0]', winrate
    avg = score / n_matches
    console.log 'avg score for player[0]', avg

  console.log 'average offset', Math.sqrt(sum_square_offset / n_matches)

  [arg] = argv._
  if arg
    require('fs').appendFileSync arg, "#{wins[0]} #{wins[1]} #{draws} #{winrate} #{avg}\n"
