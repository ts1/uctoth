#!/usr/bin/env coffee

require './rejection_handler'
fs = require 'fs'
{
  Board
  BLACK
  WHITE
  pos_to_str
  pos_from_str
  pos_array_to_str
  pos_array_from_str
} = require './board'
{ shuffle } = require './util'
make_player = require './player'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores.json')
Book = require './book'
{ encode_normalized } = require './encode'

argv = require 'yargs'
  .options
    n:
      desc: 'Number to play'
      type: 'number'
      reguiresArg: true
    d:
      alias: 'depth'
      desc: 'Depth of opening to begin with'
      type: 'number'
      default: 1
      requiresArg: true
    s:
      alias: 'search'
      desc: 'Number of UCT search per move'
      type: 'number'
      default: 14000
      requiresArg: true
    b:
      alias: 'balance'
      desc: 'Tolerance of outcome balance'
      type: 'number'
      default: 0
      requiresArg: true
    w:
      alias: 'wld'
      desc: 'Depth of win-loss-draw endgame search'
      default: 20
      requireArg: true
    f:
      alias: 'full'
      desc: 'Depth of full endgame search'
      default: 18
      requireArg: true
    h:
      alias: 'help'
  .version false
  .strict()
  .argv

balance = 0

player = make_player
  book: null
  strategy: uct
    evaluate: pattern_eval
    max_search: argv.search
    verbose: false
  verbose: false
  solve_wld: argv.wld
  solve_full: argv.full

play = (player, opening) ->
  board = new Board
  moves = []
  for {move, turn} in opening
    flips = board.move turn, move
    throw new Error 'invalid move' unless flips.length
    moves.push {move, turn}
  turn = -turn
  console.log board.dump true
  loop
    unless board.any_moves turn
      turn = -turn
      unless board.any_moves turn
        break
    {move, solved} = await player board, turn
    flips = board.move turn, move
    unless flips.length
      console.error 'invalid move'
      console.log board.dump true
      console.log move
      console.log turn
      console.log pos_to_str(move, turn)
      process.exit 1
    moves.push {move, turn, solved}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  outcome = board.outcome()
  process.stdout.write " #{outcome}\n"
  {moves, outcome}

unique_moves = (board, turn) ->
  result = []
  map = {}
  for move in board.list_moves(turn)
    flips = board.move turn, move
    code = encode_normalized board
    unless map[code]
      map[code] = true
      result.push move
    board.undo turn, move, flips
  result

find_unplayed_opening = (book, depth, cb) ->
  console.log 'depth', depth
  board = new Board
  board.move BLACK, pos_from_str('f5')
  moves = [{move:pos_from_str('f5'), turn:BLACK}]

  sub = (turn, d) ->
    if d >= depth
      data = await book.get(board)
      if data?.outcome?
        outcome = data.outcome
      else
        outcome = await cb moves
      if d > depth
        return
      if ((depth&1) and balance >= -argv.balance) or
          ((depth&1)==0 and balance <= argv.balance)
        return
      #console.log 'extending needed'
      #console.log 'outcome was', outcome
      if ((depth&1) and outcome < 0) or
          ((depth&1)==0 and outcome > 0)
        #console.log 'current move is weak, skip extending'
        return

    unless board.any_moves(turn)
      turn = -turn
      unless board.any_moves(turn)
        return
    for move in shuffle(unique_moves(board, turn))
      flips = board.move turn, move
      throw new Error 'invalid move' unless flips.length
      moves.push {move, turn}
      await sub -turn, d+1
      moves.pop()
      board.undo turn, move, flips

  await sub WHITE, 1

do ->
  book = new Book 'book.db'
  await book.init()
  balance = await book.sum_outcome() or 0
  console.log 'balance', balance

  for depth in [argv.depth..60]
    await find_unplayed_opening book, depth, (opening) ->
      if fs.existsSync('.reload-selfplay')
        process.exit 0
      console.log pos_array_to_str(opening)
      {moves, outcome} = await play(player, opening)
      moves_str = pos_array_to_str(moves)
      await book.add_game moves
      balance += outcome
      console.log 'balance', balance

      if argv.n?
        n_games = (await book.count_games()) % argv.n or argv.n
        console.log 'played', n_games
        process.exit 0 if n_games >= argv.n

      outcome
