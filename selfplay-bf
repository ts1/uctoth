#!/usr/bin/env coffee

require './rejection_handler'
fs = require 'fs'
{
  Board
  BLACK
  WHITE
  pos_to_str
  pos_from_str
  pos_array_to_str
  pos_array_from_str
} = require './board'
{ shuffle } = require './util'
make_player = require './player'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores.json')
Book = require './book'
{ encode_normalized } = require './encode'

argv = require 'yargs'
  .options
    n:
      desc: 'Number to play'
      type: 'number'
      reguiresArg: true
    d:
      alias: 'depth'
      desc: 'Depth of opening to begin with'
      type: 'number'
      default: 1
      requiresArg: true
    h:
      alias: 'help'
  .version false
  .strict()
  .argv

player = make_player
  book: null
  strategy: uct
    evaluate: pattern_eval
    verbose: false
  verbose: false
  solve_wld: 18
  solve_full: 16

play = (player, opening) ->
  board = new Board
  moves = []
  for {move, turn} in opening
    flips = board.move turn, move
    throw new Error 'invalid move' unless flips.length
    moves.push {move, turn}
  turn = -turn
  console.log board.dump true
  loop
    unless board.any_moves turn
      turn = -turn
      unless board.any_moves turn
        break
    {move, solved} = await player board, turn
    flips = board.move turn, move
    unless flips.length
      console.error 'invalid move'
      console.log board.dump true
      console.log move
      console.log turn
      console.log pos_to_str(move, turn)
      process.exit 1
    moves.push {move, turn, solved}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  outcome = board.outcome()
  process.stdout.write " #{outcome}\n"
  {moves, outcome}

unique_moves = (board, turn) ->
  result = []
  map = {}
  for move in board.list_moves(turn)
    flips = board.move turn, move
    code = encode_normalized board
    unless map[code]
      map[code] = true
      result.push move
    board.undo turn, move, flips
  result

find_unplayed_opening = (book, depth, cb) ->
  console.log 'depth', depth+1
  board = new Board
  board.move BLACK, pos_from_str('f5')
  moves = [{move:pos_from_str('f5'), turn:BLACK}]

  sub = (turn, depth) ->
    unless depth
      data = await book.get(board)
      unless data?.outcome?
        await cb moves
      return

    unless board.any_moves(turn)
      turn = -turn
      unless board.any_moves(turn)
        return
    for move in shuffle(unique_moves(board, turn))
      flips = board.move turn, move
      throw new Error 'invalid move' unless flips.length
      moves.push {move, turn}
      await sub -turn, depth-1
      moves.pop()
      board.undo turn, move, flips

  await sub WHITE, depth

do ->
  book = new Book 'book.db'
  await book.init()

  for depth in [(argv.depth-1)..60]
    await find_unplayed_opening book, depth, (opening) ->
      if fs.existsSync('.reload-selfplay')
        process.exit 0
      console.log pos_array_to_str(opening)
      {moves, outcome} = await play(player, opening)
      moves_str = pos_array_to_str(moves)
      await book.add_game moves

      if argv.n?
        n_games = (await book.count_games()) % argv.n or argv.n
        console.log 'played', n_games
        process.exit 0 if n_games >= argv.n
