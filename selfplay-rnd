#!/usr/bin/env coffee

require './rejection_handler'
fs = require 'fs'
{ Board, BLACK, pos_to_str, pos_array_to_str, pos_array_from_str } =
  require './board'
Player = require './player'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores.json')
Book = require './book'
{ int } = require './util'

argv = require 'yargs'
  .usage "Usage: #{process.argv[1]} [options...]"
  .options
    o:
      alias: 'opening'
      desc: 'Opening'
      type: 'string'
      default: 'F5'
      requiresArg: true
    n:
      desc: 'Number of games to play'
      type: 'number'
      requiresArg: true
    R:
      alias: 'random-play'
      desc: 'Random play mode'
      type: 'boolean'
      default: false
    r:
      alias: 'randomness'
      desc: 'Initial randomness'
      type: 'number'
      default: 0.1
      requiresArg: true
    min_col:
      desc: 'Minimum collision rate'
      type: 'number'
      default: 0.1
      requiresArg: true
    max_col:
      desc: 'Maximum collision rate'
      type: 'number'
      default: 0.2
      requiresArg: true
    D:
      desc: 'Collision average duration'
      type: 'number'
      default: 20
      requiresArg: true
    b:
      alias: 'balance'
      desc: 'Tolerance of outcome balance'
      type: 'number'
      default: 400
      requiresArg: true
    B:
      alias: 'book'
      desc: 'Database file to save games'
      type: 'string'
      default: 'book.db'
      requiresArg: true
    s:
      alias: 'search'
      desc: 'Number of UCT searches per move'
      type: 'number'
      default: 14000
      requireArg: true
    w:
      alias: 'wld'
      desc: 'Depth of win-loss-draw endgame search'
      default: 20
      requireArg: true
    f:
      alias: 'full'
      desc: 'Depth of full endgame search'
      default: 18
      requireArg: true
    d:
      alias: 'depth'
      desc: 'Learn depth'
      default: 5
      requireArg: true
    v:
      alias: 'verbose'
      default: false
      type: 'boolean'
    h:
      alias: 'help'
  .version false
  .strict()
  .argv

make_player = (randomness) ->
  Player
    book: null
    strategy: uct
      evaluate: if argv.R then (-> Math.random()) else pattern_eval
      max_search: if argv.R then 1 else argv.s
      verbose: false
      random: randomness
    verbose: false
    solve_wld: argv.w
    solve_full: argv.f

play = (player) ->
  board = new Board
  turn = BLACK
  moves = []
  for move in pos_array_from_str(argv.opening)
    flips = board.move turn, move
    throw new Error unless flips.length
    moves.push {move, turn}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  loop
    unless board.any_moves turn
      turn = -turn
      unless board.any_moves turn
        break
    {move, solved} = await player board, turn
    flips = board.move turn, move
    console.assert flips.length
    moves.push {move, turn, solved}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  outcome = board.outcome()
  process.stdout.write " #{outcome}\n"
  {moves, outcome}

do ->
  book = new Book argv.book,
    solve_wld: argv.wld, solve_full: argv.full, eval_depth: argv.depth
  await book.init()

  randomness = argv.randomness
  player = make_player(randomness)

  balance = (await book.sum_outcome()) or 0
  console.log "balance #{balance}"
  n_col = 0
  n_play = 0
  n_skip = 0
  avg_col = (argv.min_col + argv.max_col) / 2
  loop
    if fs.existsSync('.reload-selfplay')
      break

    {moves, outcome} = await play player
    moves_str = pos_array_to_str(moves)

    b = balance + outcome
    if (b > argv.b and outcome > 0) or (b < -argv.b and outcome < 0)
      console.log "SKIP FOR BALANCE (current #{balance})"
      n_skip++
      continue

    n_play++

    collision = await book.has_game(moves_str)
    if collision
      n_col++
      console.log "COLLISION #{n_col}/#{n_play}"

    avg_col = (avg_col * (argv.D - 1) + int(collision)) / argv.D

    if avg_col > argv.max_col
      randomness *= 1.01
      player = make_player(randomness)
      console.log 'collision rate', avg_col, 'randomness', randomness if argv.v
    else if avg_col < argv.min_col
      randomness *= 0.99
      player = make_player(randomness)
      console.log 'collision rate', avg_col, 'randomness', randomness if argv.v

    if collision
      continue

    balance += outcome
    await book.add_game moves
    if argv.n?
      n_games = (await book.count_games()) % argv.n or argv.n
      console.log 'played', n_games
      break if n_games >= argv.n
  console.log "played #{n_play + n_skip} collision #{n_col} skipped #{n_skip} balance #{balance}"
