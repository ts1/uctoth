#!/usr/bin/env coffee

require './rejection_handler'
fs = require 'fs'
{ Board, BLACK, pos_to_str, pos_array_to_str, pos_array_from_str } =
  require './board'
Player = require './player'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores.json')
Book = require './book'
{ int, watch_file } = require './util'

argv = require 'yargs'
  .usage "Usage: #{process.argv[1]} [options...]"
  .options
    o:
      alias: 'opening'
      desc: 'Opening'
      type: 'string'
      default: 'F5'
      requiresArg: true
    n:
      desc: 'Number of games to play'
      type: 'number'
      requiresArg: true
    R:
      alias: 'random-play'
      desc: 'Random play mode'
      type: 'boolean'
      default: false
    r:
      alias: 'randomness'
      desc: 'Initial randomness'
      type: 'number'
      default: 0.07
      requiresArg: true
    min_col:
      desc: 'Minimum collision rate'
      type: 'number'
      default: 0.1
      requiresArg: true
    max_col:
      desc: 'Maximum collision rate'
      type: 'number'
      default: 0.2
      requiresArg: true
    D:
      desc: 'Collision average duration'
      type: 'number'
      default: 20
      requiresArg: true
    a:
      alias: 'auto_opening'
      desc: 'Automaticaly select opening according to balance'
      type: 'boolean'
      default: false
    b:
      alias: 'balance'
      desc: 'Tolerance of outcome balance'
      type: 'number'
      default: 400
      requiresArg: true
    B:
      alias: 'book'
      desc: 'Database file to save games'
      type: 'string'
      default: 'book.db'
      requiresArg: true
    s:
      alias: 'search'
      desc: 'Number of UCT searches per move'
      type: 'number'
      default: 14000
      requireArg: true
    w:
      alias: 'wld'
      desc: 'Depth of win-loss-draw endgame search'
      type: 'number'
      default: 20
      requireArg: true
    f:
      alias: 'full'
      desc: 'Depth of full endgame search'
      type: 'number'
      default: 18
      requireArg: true
    d:
      alias: 'depth'
      desc: 'Learn depth'
      type: 'number'
      default: 5
      requireArg: true
    watch:
      desc: 'Watch the file and exit when it changes'
      default: 'scores.json'
      type: 'string'
      requireArg: true
    v:
      alias: 'verbose'
      default: false
      type: 'boolean'
    h:
      alias: 'help'
  .version false
  .strict()
  .argv

make_player = (randomness) ->
  Player
    book: null
    strategy: uct
      evaluate: if argv.R then (-> Math.random()) else pattern_eval
      max_search: if argv.R then 1 else argv.s
      verbose: false
      random: randomness
    verbose: false
    solve_wld: argv.w
    solve_full: argv.f

play = (player, opening) ->
  board = new Board
  turn = BLACK
  moves = []
  for move in pos_array_from_str(opening)
    flips = board.move turn, move
    throw new Error unless flips.length
    moves.push {move, turn}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  loop
    unless board.any_moves turn
      turn = -turn
      unless board.any_moves turn
        break
    {move, solved} = player board, turn
    flips = board.move turn, move
    console.assert flips.length
    moves.push {move, turn, solved}
    process.stdout.write pos_to_str(move, turn)
    turn = -turn
  outcome = board.outcome()
  process.stdout.write " #{outcome}\n"
  {moves, outcome}

do ->
  book = new Book argv.book,
    solve_wld: argv.wld, solve_full: argv.full, eval_depth: argv.depth
  book.init()

  randomness = argv.randomness
  player = make_player(randomness)

  n_col = 0
  n_play = 0
  n_skip = 0
  n_save = 0
  avg_col = (argv.min_col + argv.max_col) / 2
  reload = if argv.watch then watch_file(argv.watch) else -> false
  until reload()
    balance = book.sum_outcome() or 0
    console.log "balance #{balance}"

    opening = argv.opening
    if argv.auto_opening
      if balance > 0
        opening = 'F5d6'
      else if balance > -argv.balance * .5
        opening = 'F5f6'
      else
        opening = 'F5f4'

    {moves, outcome} = play player, opening
    moves_str = pos_array_to_str(moves)

    b = balance + outcome
    if (b > argv.b and outcome > 0) or (b < -argv.b and outcome < 0)
      console.log "NOT ACCEPTED DUE TO BALANCE"
      n_skip++
      continue

    n_play++

    collision = book.has_game(moves_str)
    if collision
      n_col++
      console.log "COLLISION #{n_col}/#{n_play}"

    avg_col = (avg_col * (argv.D - 1) + int(collision)) / argv.D
    orig_randomness = randomness

    if collision and avg_col > argv.max_col
      randomness *= 1.07
    else if avg_col < argv.min_col
      randomness *= 0.99

    if randomness != orig_randomness
      player = make_player(randomness)
      console.log 'collision rate', avg_col, 'randomness', randomness if argv.v

    if collision
      continue

    book.add_game moves
    break if ++n_save >= argv.n
  balance = book.sum_outcome() or 0
  console.log "played #{n_play + n_skip} collision #{n_col} skipped #{n_skip} balance #{balance}"
