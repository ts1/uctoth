#!/usr/bin/env coffee

require './rejection_handler'
readline = require 'readline'
{ Board, BLACK, WHITE, pos_array_from_str, pos_to_str, pos_from_str, pos_array_to_str } = require './board'
{ encode_normalized, decode } = require './encode'
{ readlines, gzwriter } = require './util'

root =
  code: encode_normalized new Board
  turn: BLACK
  parents:[]
  children:[]
  score:0

map = {}

replay_and_minmax = (moves, score) ->
  board = new Board
  turn = BLACK
  parent = root
  n_moves = 0
  for move in moves
    n_moves++
    flips = board.move turn, move
    unless flips.length
      throw new Error 'invalid move', pos_to_str move
    if board.any_moves -turn
      turn = -turn
    code = encode_normalized board
    node = map[code]
    if node
      node.n++
      if parent not in node.parents
        node.parents.push parent
    else
      node =
        code: code
        turn: turn
        parents: [parent]
        children: []
        score: 0
        n: 1
        moves: n_moves
      map[code] = node
    if node not in parent.children
      parent.children.push node

    parent = node

  if board.any_moves(turn) or board.any_moves(-turn)
    throw new Error 'game not finished'
  if score != board.outcome()
    throw new Error 'score invalid'

  node.score = score
  node.turn = 0

  minmax = (node) ->
    max = -Infinity
    for child in node.children
      value = child.score * node.turn
      if value > max
        max = value
    node.score = max * node.turn
    for parent in node.parents
      minmax parent

  for parent in node.parents
    minmax parent

if process.argv.slice(2).length < 1
  process.stderr.write "Usage: #{process.argv[1]} games\n"
  process.exit 1

do ->
  n = 0
  for infile in process.argv.slice(2)
    process.stderr.write "loading #{infile}\n"
    await readlines infile, (line) ->
      [moves, score] = line.split ' '
      moves = pos_array_from_str moves
      score = parseInt score
      replay_and_minmax moves, score
      n += 1
  process.stderr.write "loaded #{n} games\n"

  process.stderr.write "dumping nodes to stdout\n"
  n = 0
  for code, node of map
    process.stdout.write "#{decode(code)} #{node.turn} #{node.score} #{node.n} #{node.moves}\n"
    n += 1
  process.stderr.write "dumped #{n} nodes\n"

  if 1
    board = new Board
    board.move BLACK, pos_from_str('F5')
    moves = [pos_from_str('f5')]

    dump_score = (turn, depth) ->
      if depth == 0
        node = map[encode_normalized board]
        if node
          process.stderr.write "#{pos_array_to_str(moves)} #{node.score}\n"
      else
        for move in board.list_moves turn
          flips = board.move turn, move
          moves.push move
          dump_score -turn, depth-1
          board.undo turn, move, flips
          moves.pop()

    for depth in [0..2]
      process.stderr.write "d=#{depth}\n"
      dump_score WHITE, depth
