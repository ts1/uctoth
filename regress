#!/usr/bin/env coffee

{ readlines, gzwriter } = require './util'
{ get_single_index_size } = require './pattern'
yargs = require 'yargs'
  .usage "Usage: #{process.argv[1]} [options] indexes coeffs"
  .options
    t:
      desc: 'threshold to terminate regression'
      alias: 'threshold'
      default: 1e-3
      type: 'number'
      requiresArg: true
argv = yargs.argv

D_FACTOR = 120

index_size = get_single_index_size()

each_index = (row, cb) ->
  for i in [1...row.length] by 2
    cb row[i], row[i+1]

predict = (coeffs, row) ->
  result = 0
  each_index row, (index, value) ->
    result += coeffs[index] * value
  result

verify = (rows, coeffs) ->
  sum_sq_err = 0
  rows.forEach (row) ->
    outcome = row[0]
    e = outcome - predict(coeffs, row)
    sum_sq_err += e*e
  Math.sqrt(sum_sq_err / rows.length)

make_gradient = (rows, coeffs) ->
  vector = (0 for i in [0...index_size] by 1)
  sum = 0
  for row from rows
    outcome = row[0]
    e = outcome - predict(coeffs, row)
    each_index row, (index, value) ->
      vector[index] += e * value
  vector

update_coeffs = (coeffs, vector, rate) ->
  coeffs[i] + vector[i] * rate for i in [0...index_size] by 1

read_rows = (filename, split) ->
  console.log "loading #{filename}"
  rows = []
  await readlines filename, (line) ->
    rows.push JSON.parse line
  rows

average = (rows) ->
  sum = 0
  for row in rows
    sum += row[0]
  sum / rows.length

regress = (index_file) ->
  train_set = await read_rows index_file
  console.log "train set #{train_set.length}"
  avg = average train_set
  console.log "avg #{avg}"
  coeffs = (0 for i in [0...index_size] by 1)
  dev = last_loss = verify train_set, coeffs
  console.log 'deviation', last_loss

  n = 0
  step = 1
  d_avg = 0
  rate = 1
  loop
    vector = make_gradient train_set, coeffs

    changed = false
    loop
      new_coeffs = update_coeffs coeffs, vector, rate
      loss = verify train_set, new_coeffs
      break if loss < last_loss
      rate *= 0.7
      changed = true
    if changed
      console.log 'rate', rate * train_set.length
    coeffs = new_coeffs

    d = last_loss - loss
    if step <= D_FACTOR
      d_avg = (d_avg * (step - 1) + d) / step
    else
      d_avg = (d_avg * (D_FACTOR - 1) + d) / D_FACTOR
    console.log 'step', step, 'loss', loss, 'd', d_avg
    break if d_avg < argv.threshold

    step++

    last_loss = loss

    n++
    if n >= 30
      rate *= 10000
      n = 0

  r2 = 1 - last_loss**2 / dev**2
  console.log 'r2', r2

  {coeffs, r2, step, loss:last_loss, avg}

if argv._.length == 2
  [index_file, outfile] = argv._
else
  yargs.showHelp()
  process.exit 1

do ->
  coeffs = await regress index_file
  gzwriter(outfile).end(JSON.stringify coeffs)
