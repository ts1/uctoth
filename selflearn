#!/usr/bin/env coffee
require './rejection_handler'
{ pos_array_to_str, pos_to_str, BLACK, WHITE, pos_array_from_str } = require './board'
{ PatternBoard } = require './pattern'
Book = require './book'
fs = require 'fs'
Player = require './player'
minmax = require './minmax'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores')
{ round_value } = require './util'

C = 1
Cplay = C
EVAL_DEPTH = 7
WLD = 18
FULL = 16
OPENING = pos_array_from_str('F5')

evaluator = do ->
  eval1 = Player
    book: null
    strategy: minmax
      evaluate: pattern_eval
      verbose: false
      max_depth: EVAL_DEPTH
      cache_size: 100000
    solve_wld: WLD
    solve_full: FULL
    verbose: false
  eval2 = Player
    book: null
    strategy: minmax
      evaluate: pattern_eval
      verbose: false
      max_depth: EVAL_DEPTH-1
      cache_size: 100000
    solve_wld: WLD
    solve_full: FULL
    verbose: false
  (board, me, moves) ->
    move = await eval1(board, me, moves)
    if move.solved
      return move
    move2 = await eval2(board, me, [move.move])
    move.value = (move.value + move2.value) / 2
    move

player = Player
  book: null
  strategy: uct
    evaluate: pattern_eval
    verbose: false
    C: 1.9
    max_search: 14000
  solve_wld: WLD
  solve_full: FULL
  verbose: false

book = new Book 'book.db'

n_black = n_white = 0

learn = (play) ->
  {board, moves, turn, value} = await book.find_opening(C, OPENING)
  console.log (pos_to_str(move.move, move.turn) for move in moves).join(''), round_value(value)
  console.log board.dump true
  await book.learn moves, await evaluator
  if play
    opening = await book.find_unplayed_opening(Cplay, OPENING)
    if opening
      {board, moves, turn, value} = opening

      if (value > 0 and n_black > n_white) or (value < 0 and n_black < n_white)
        console.log 'skip this opening to balance'
        return

      console.log 'new opening:', (pos_to_str(move.move, move.turn) for move in moves).join(''), round_value(value)
      console.log board.dump true
      await book.learn moves, await evaluator
      loop
        unless board.any_moves turn
          turn = -turn
          unless board.any_moves turn
            break
        {move, solved} = await player board, turn
        board.move turn, move
        moves.push {move, solved, turn}
        process.stdout.write pos_to_str move, turn
        turn = -turn
      outcome = board.outcome()
      console.log ':', outcome
      fs.appendFileSync 'games', "#{(pos_to_str(move, turn) for {move, turn} in moves).join('')} #{outcome}\n"
      book.save_game moves, outcome
      n_black++ if outcome > 0
      n_white++ if outcome < 0
      console.log 'black', n_black, 'white', n_white

do ->
  [arg] = process.argv.slice 2
  check_reload = false
  if arg == 'loop'
    play = true
    max_games = 0
    check_reload = true
  else if arg
    max_games = parseInt arg
    play = true
  else
    max_games = 0
    play = false

  await book.init()
  n_black = await book.count_games(BLACK)
  n_white = await book.count_games(WHITE)
  loop
    if check_reload and fs.existsSync('.reload-selfplay')
      break
    if max_games
      n_games = await book.count_games()
      console.log 'played', n_games
      if n_games >= max_games
        break
    await learn(play)
    #console.log 'heap used', process.memoryUsage().heapUsed/1024/1024, 'MB'
