#!/usr/bin/env coffee
{ pos_array_to_str, pos_to_str, BLACK, pos_array_from_str } = require './board'
{ PatternBoard } = require './pattern'
Book = require './book'
fs = require 'fs'
Player = require './player'
minmax = require './minmax'
uct = require './uct'
pattern_eval = require('./pattern_eval')('scores')
{ round_value } = require './util'

C = 2
Cplay = C
EVAL_DEPTH = 8
PLAY_DEPTH = 8
WLD = 18
FULL = 16
FIRST_MOVE = pos_array_from_str('F5')

process.on 'unhandledRejection', (reason) ->
  console.trace reason
  process.exit 1

evaluator = do ->
  eval1 = Player
    book: null
    strategy: minmax
      evaluate: pattern_eval
      verbose: false
      max_depth: EVAL_DEPTH
      cache_size: 100000
    solve_wld: WLD
    solve_full: FULL
    verbose: false
  eval2 = Player
    book: null
    strategy: minmax
      evaluate: pattern_eval
      verbose: false
      max_depth: EVAL_DEPTH-1
      cache_size: 100000
    solve_wld: WLD
    solve_full: FULL
    verbose: false
  (board, me, moves) ->
    move = await eval1(board, me, moves)
    if move.solved
      return move
    move2 = await eval2(board, me, [move.move])
    move.value = (move.value + move2.value) / 2
    move

player = Player
  book: null
  strategy: uct
    evaluate: pattern_eval
    verbose: false
    C: 1.9
    max_search: 14000
  solve_wld: WLD
  solve_full: FULL
  verbose: false

book = new Book 'book.db'

learn = (play) ->
  {board, moves, turn, value} = await book.find_opening(C, FIRST_MOVE)
  console.log pos_array_to_str(move.move for move in moves), round_value(value)
  console.log board.dump true
  await book.learn moves, await evaluator
  if play
    opening = await book.find_unplayed_opening(Cplay, FIRST_MOVE)
    if opening
      {board, moves, turn, value} = opening
      console.log 'new opening:', pos_array_to_str(move.move for move in moves), round_value(value)
      console.log board.dump true
      await book.learn moves, await evaluator
      loop
        unless board.any_moves turn
          turn = -turn
          unless board.any_moves turn
            break
        {move, solved} = await player board, turn
        board.move turn, move
        moves.push {move, solved}
        process.stdout.write pos_to_str move
        turn = -turn
      console.log ':', board.outcome()
      fs.appendFileSync 'games', "#{pos_array_to_str(move.move for move in moves)} #{board.outcome()}\n"
      book.save_game moves, board.outcome()

do ->
  [arg] = process.argv.slice 2
  if arg
    max_games = parseInt arg
    play = true
  else
    max_games = 0
    play = false

  await book.init()
  loop
    if max_games
      n_games = await book.count_games()
      console.log 'played', n_games
      if n_games >= max_games
        break
    await learn(play)
    #console.log 'heap used', process.memoryUsage().heapUsed/1024/1024, 'MB'
